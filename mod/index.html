<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="author" content="">

<title>New HMTL document by NewJect</title>
<style>
    .canva{
        position: absolute;top: 0px;left: 0px;
        width: 95vw;
        height: 95vh;
        background-color: bl;
        z-index: -1;
        filter:blur(4px);
    }
    .bg_1{
        position: absolute;top: 0px;left: 0px;
        width: 95vw;
        height: 95vh;
        background: url(img/bg_1.png) no-repeat;        
        background-position: center;
        background-size:2200px;
    }
/*    .canva canvas{width:100%;height:100%;}*/
    </style>
</head>
<body>

<div class="bg_1">
<h3>this is new html document generated by newject extention</h3>
</div>

<div class="canva">
<canvas id="myCanvas" width="" height="">
  your browser doesn't support canvas!
</canvas>
</div>
<script>    
    var canvas=document.getElementById('myCanvas');
//    创建画布并设置画布宽高
    var C_width =(document.documentElement.clientWidth)*(0.95);
    var C_height =(document.documentElement.clientHeight)*(0.95);
    canvas.width = C_width;
    canvas.height = C_height;
    var context = canvas.getContext('2d');
//    粒子对象
    var parts=[];
//    未来位置
    var fut_pos=[];
//    运动速度
    var Speeder= 1;
    window.onload=function(){
        create_obj();
        create_fut();
        cre_part();
        setInterval('motion()',30);
    }
//    生成对象
    function create_obj(){        
        for(var i=0;i<30;i++){
            var part={
                x:getRadom(C_width,1),
                y:getRadom(C_height,1),
                size:getRadom(8,3)
            };
            parts.push(part);
        }
        console.log(parts[2]);
    }
//    生成未来位置
    function create_fut(){
        for(var i=0;i<parts.length;i++){
            var fut={
                fut_x:getRadom(C_width,1),
                fut_y:getRadom(C_height,1)
            };
            fut_pos.push(fut);
        }
        console.log(fut_pos[2]);
    }
//    绘制粒子
    function cre_part(){ 
        context.fillStyle='#FF0000';
        context.shadowColor = '#FF0500';
        context.shadowBlur = 10;
        context.shadowOffsetX = 2;
        context.shadowOffsetY = 2;
        for(var i=0;i<parts.length;i++){
            context.beginPath();
            context.arc(parts[i].x, parts[i].y,parts[i].size,0,  Math.PI * 2);
            context.fill();
//          context.stroke();
            context.closePath();
        }
    }
//    运动粒子
    function motion(){
        context.clearRect(0,0,C_width,C_height);
        for(var i=0;i<parts.length;i++){
//            计算运动偏移量
//            var px=parseInt(((parts[i].x-fut_pos[i].fut_x)/Speeder));
//            var py=parseInt(((parts[i].y-fut_pos[i].fut_y)/Speeder));
            if((parts[i].x-fut_pos[i].fut_x)<0){                
               parts[i].x =parts[i].x+Speeder;               
            }else {
               parts[i].x =parts[i].x-Speeder;              
            }            
            if((parts[i].y-fut_pos[i].fut_y)<0){
                parts[i].y =parts[i].y+Speeder;
            }else {
                parts[i].y =parts[i].y-Speeder;
            }
             console.log('预计位置x:'+fut_pos[i].fut_x+';y:'+fut_pos[i].fut_y);
             console.log('现在位置x:'+parts[i].x+';y:'+parts[i].y);
//            判断是否抵达预定位置
            if(parts[i].x==fut_pos[i].fut_x||parts[i].y==fut_pos[i].fut_y){
//                alert(12);
                fut_pos[i].fut_x=getRadom(C_height,1);
                fut_pos[i].fut_y=getRadom(C_height,1);
            }            
            context.beginPath();
            context.arc(parts[i].x, parts[i].y,parts[i].size,0,  Math.PI * 2);
            context.fill();
//          context.stroke();
            context.closePath();
        }
    }
    function getRadom(max,min){
        return parseInt((Math.random()*(max-min)+min));
    }
    </script>
</body>
</html>